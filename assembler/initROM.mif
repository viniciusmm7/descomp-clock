WIDTH=13;
DEPTH=512;
ADDRESS_RADIX=DEC;
DATA_RADIX=BIN;

CONTENT BEGIN
0	: 0000000000000;	-- 	 SETUP
1	: 0101111111111;	-- STA @511    	 reseta a leitura do key 0
2	: 0101111111110;	-- STA @510    	 reseta a leitura do key 1
3	: 0101111111101;	-- STA @509    	 reseta a leitura do key reset
4	: 0100000000000;	-- LDI $0      	 carrega o valor inicial das casas
5	: 0101000111001;	-- STA @57     	 intervalo numérico de configuração
6	: 0101000000000;	-- STA @0      	 armazena 0 na unidade
7	: 0101000000001;	-- STA @1      	 armazena 0 na dezena
8	: 0101000000010;	-- STA @2      	 armazena 0 na centena
9	: 0101000000011;	-- STA @3      	 armazena 0 no milhar
10	: 0101000000100;	-- STA @4      	 armazena 0 na dezena de milhar
11	: 0101000000101;	-- STA @5      	 armazena 0 na centena de milhar
12	: 0101000001000;	-- STA @8      	 armazena um 0 de referência
13	: 0100000000001;	-- LDI $1      	 carrega o valor de incremento
14	: 0101000000110;	-- STA @6      	 armazena o valor de incremento
15	: 0101000001001;	-- STA @9			 armazena 1 no 9 para referência do intervalo numérico de configuração
16	: 0100000001010;	-- LDI $10     	 carrega o valor máximo por casa possível
17	: 0101000000111;	-- STA @7      	 armazena o valor máximo por casa possível
18	: 0100000001001;	-- LDI $9      	 carrega o número 9 para definir o limite de contagem inicial
19	: 0101000111010;	-- STA @58     	 armazena na casa das unidades do limite
20	: 0101000111011;	-- STA @59     	 armazena na casa das dezenas do limite
21	: 0101000111100;	-- STA @60     	 armazena na casa das centenas do limite
22	: 0101000111101;	-- STA @61     	 armazena na casa dos milhares do limite
23	: 0101000111110;	-- STA @62     	 armazena na casa das dezenas de milhar do limite
24	: 0101000111111;	-- STA @63     	 armazena na casa das centenas de milhar do limite
25	: 0100000000010;	-- LDI $2			 carrega 2 para inicializar próximo endereço de referência do intervalo numérico de configuração
26	: 0101000001010;	-- STA @10			 armazena a referência de estado 2 no endereço 10
27	: 0100000000011;	-- LDI $3			 carrega 3 para inicializar próximo endereço de referência do intervalo numérico de configuração
28	: 0101000001011;	-- STA @11			 armazena a referência de estado 3 no endereço 11
29	: 0100000000100;	-- LDI $4			 carrega 4 para inicializar próximo endereço de referência do intervalo numérico de configuração
30	: 0101000001100;	-- STA @12			 armazena a referência de estado 4 no endereço 12
31	: 0001101100100;	-- LDA @356    	 carrega o valor do botão reset
32	: 1011000000110;	-- AND @6      	 aplica a mask
33	: 1000000001000;	-- CEQ @8      	 verifica se é 0
34	: 0111000100101;	-- JEQ .PULA_RESET
35	: 0101111111101;	-- STA @509
36	: 1001001010010;	-- JSR .RESET
37	: 0001101100001;	-- LDA @353    	 carrega o valor do botão 1
38	: 1011000000110;	-- AND @6      	 aplica a mask
39	: 1000000001000;	-- CEQ @8      	 verifica se é 0
40	: 0111000101011;	-- JEQ .PULA_CONFIG
41	: 0101111111110;	-- STA @510
42	: 0110000110110;	-- JMP .INICIO_LOOP_CONFIGURACAO_LIMITE
43	: 1001101000111;	-- JSR .ATINGIU_LIMITE			 verifica se a contagem atingiu o limite
44	: 1000000000110;	-- CEQ @6						 se atingiu o limite, pula o incrementa contagem
45	: 0111000110100;	-- JEQ .PULA_INCREMENTA_CONTAGEM
46	: 0001101100000;	-- LDA @352    	 carrega o valor do botão 0
47	: 1011000000110;	-- AND @6      	 aplica a mask
48	: 1000000001000;	-- CEQ @8      	 verifica se é 0
49	: 0111000110100;	-- JEQ .PULA_INCREMENTA_CONTAGEM
50	: 0101111111111;	-- STA @511
51	: 1001001100001;	-- JSR .INCREMENTA_CONTAGEM
52	: 1001010010010;	-- JSR .MOSTRA_CONTAGEM    	 escreve os números da contagem nos displays
53	: 0110000011111;	-- JMP .LOOP_PRINCIPAL
54	: 1001001010010;	-- JSR .RESET		 reseta a contagem
55	: 0100000000011;	-- LDI $3			 acende os leds da primeira posição
56	: 0101100000000;	-- STA @256
57	: 0100000000000;	-- LDI $0
58	: 0101100000001;	-- STA @257
59	: 0101100000010;	-- STA @258
60	: 0001101100100;	-- LDA @356    	 carrega o valor do botão reset
61	: 1011000000110;	-- AND @6      	 aplica a mask
62	: 1000000000110;	-- CEQ @6      	 verifica se é 1
63	: 0111001001110;	-- JEQ .SAIR_LOOP_CONFIGURACAO_LIMITE
64	: 0001101100001;	-- LDA @353    	 carrega o valor do botão 1
65	: 1011000000110;	-- AND @6      	 aplica a mask
66	: 1000000001000;	-- CEQ @8      	 verifica se é 0
67	: 0111001000110;	-- JEQ .PULA_MUDANCA_ESTADO
68	: 0101111111110;	-- STA @510
69	: 0110001001110;	-- JMP .SAIR_LOOP_CONFIGURACAO_LIMITE
70	: 0001101100000;	-- LDA @352    	 carrega o valor do botão 0
71	: 1011000000110;	-- AND @6      	 aplica a mask
72	: 1000000001000;	-- CEQ @8      	 verifica se é 0
73	: 0111001001100;	-- JEQ .PULA_MUDANCA_INTERVALO
74	: 0101111111111;	-- STA @511
75	: 1001011111110;	-- JSR .MUDA_INTERVALO
76	: 1001010011111;	-- JSR .MOSTRA_LIMITE
77	: 0110000111100;	-- JMP .LOOP_CONFIGURACAO_LIMITE
78	: 1001011111001;	-- JSR .APAGA_LEDS         	 apaga os LEDs
79	: 0100000000000;	-- LDI $0    		 carrega 0
80	: 0101000111001;	-- STA @57     	 armazena 0 no intervalo de mudança atual
81	: 0110000011111;	-- JMP .LOOP_PRINCIPAL
82	: 0100000000000;	-- LDI $0
83	: 0101000000000;	-- STA @0
84	: 0101000000001;	-- STA @1
85	: 0101000000010;	-- STA @2
86	: 0101000000011;	-- STA @3
87	: 0101000000100;	-- STA @4
88	: 0101000000101;	-- STA @5
89	: 0100000000000;	-- LDI $0
90	: 0101100000000;	-- STA @256
91	: 0101100000001;	-- STA @257
92	: 0101100000010;	-- STA @258
93	: 0101111111111;	-- STA @511
94	: 0101111111110;	-- STA @510
95	: 0101111111101;	-- STA @509
96	: 1010000000000;	-- RET
97	: 0001000000000;	-- LDA @0                  	 carrega o valor da unidade
98	: 0010000000110;	-- ADD @6                  	 incrementa o valor da unidade
99	: 1000000000111;	-- CEQ @7                  	 compara o valor da casa com 10
100	: 0111001100111;	-- JEQ .INCREMENTA_DEZENA  	 incrementa a casa da dezena caso necessário
101	: 0101000000000;	-- STA @0                  	 armazena o valor da unidade
102	: 1010000000000;	-- RET
103	: 0100000000000;	-- LDI $0                  	 carrega 0
104	: 0101000000000;	-- STA @0                  	 armazena 0 na unidade
105	: 0001000000001;	-- LDA @1                  	 carrega o valor atual da dezena
106	: 0010000000110;	-- ADD @6                  	 incrementa o valor da dezena
107	: 1000000000111;	-- CEQ @7                  	 verifica se é igual a 10
108	: 0111001101111;	-- JEQ .INCREMENTA_CENTENA 	 se for, incrementa a centena
109	: 0101000000001;	-- STA @1                  	 armazena o novo valor da dezena
110	: 0110001100110;	-- JMP .FIM_INCREMENTA     	 sai da função
111	: 0100000000000;	-- LDI $0                  	 carrega 0
112	: 0101000000001;	-- STA @1                  	 armazena 0 na dezena
113	: 0001000000010;	-- LDA @2                  	 carrega o valor atual da centena
114	: 0010000000110;	-- ADD @6                  	 incrementa o valor da centena
115	: 1000000000111;	-- CEQ @7                  	 verifica se é igual a 10
116	: 0111001110111;	-- JEQ .INCREMENTA_MILHAR  	 se for, incrementa o milhar
117	: 0101000000010;	-- STA @2                  	 armazena o novo valor da centena
118	: 0110001100110;	-- JMP .FIM_INCREMENTA     	 sai da função
119	: 0100000000000;	-- LDI $0                  	 carrega 0
120	: 0101000000010;	-- STA @2                  	 armazena 0 na centena
121	: 0001000000011;	-- LDA @3                  	 carrega o valor atual do milhar
122	: 0010000000110;	-- ADD @6                  	 incrementa o valor do milhar
123	: 1000000000111;	-- CEQ @7                  	 verifica se é igual a 10
124	: 0111001111111;	-- JEQ .INCREMENTA_DMILHAR 	 se for, incrementa a dezena de milhar
125	: 0101000000011;	-- STA @3                  	 armazena o novo valor do milhar
126	: 0110001100110;	-- JMP .FIM_INCREMENTA     	 sai da função
127	: 0100000000000;	-- LDI $0                  	 carrega 0
128	: 0101000000011;	-- STA @3                  	 armazena 0 no milhar
129	: 0001000000100;	-- LDA @4                  	 carrega o valor atual da dezena de milhar
130	: 0010000000110;	-- ADD @6                  	 incrementa o valor da dezena de milhar
131	: 1000000000111;	-- CEQ @7                  	 verifica se é igual a 10
132	: 0111010000111;	-- JEQ .INCREMENTA_CMILHAR 	 se for, incrementa a centena de milhar
133	: 0101000000100;	-- STA @4                  	 armazena o novo valor da dezena de milhar
134	: 0110001100110;	-- JMP .FIM_INCREMENTA     	 sai da função
135	: 0100000000000;	-- LDI $0                  	 carrega 0
136	: 0101000000100;	-- STA @4                  	 armazena 0 na dezena de milhar
137	: 0001000000101;	-- LDA @5                  	 carrega o valor atual da centena de milhar
138	: 0010000000110;	-- ADD @6                  	 incrementa o valor da centena de milhar
139	: 1000000000111;	-- CEQ @7                  	 verifica se é igual a 10
140	: 0111010001111;	-- JEQ .INCREMENTA_MILHAO  	 se for, zera tudo
141	: 0101000000101;	-- STA @5                  	 armazena o novo valor da centena de milhar
142	: 0110001100110;	-- JMP .FIM_INCREMENTA     	 sai da função
143	: 0100000000000;	-- LDI $0  	 carrega 0
144	: 0101000000101;	-- STA $5  	 armazena 0 na centena de milhar
145	: 0110001100110;	-- JMP .FIM_INCREMENTA
146	: 0001000000000;	-- LDA @0      	 carrega o valor da unidade
147	: 0101100100000;	-- STA @288    	 armazena no HEX 0
148	: 0001000000001;	-- LDA @1      	 carrega o valor da dezena
149	: 0101100100001;	-- STA @289    	 armazena no HEX 1
150	: 0001000000010;	-- LDA @2      	 carrega o valor da centena
151	: 0101100100010;	-- STA @290    	 armazena no HEX 2
152	: 0001000000011;	-- LDA @3      	 carrega o valor do milhar
153	: 0101100100011;	-- STA @291    	 armazena no HEX 3
154	: 0001000000100;	-- LDA @4      	 carrega o valor da dezena de milhar
155	: 0101100100100;	-- STA @292    	 armazena no HEX 4
156	: 0001000000101;	-- LDA @5      	 carrega o valor da centena de milhar
157	: 0101100100101;	-- STA @293    	 armazena no HEX 5
158	: 1010000000000;	-- RET
159	: 0001000111001;	-- LDA @57                 	 carrega o intervalo atual
160	: 1000000001000;	-- CEQ @8                  	 verifica se é igual a 0
161	: 0111010101011;	-- JEQ .DIGITO_0_ML     	 se for
162	: 1000000001001;	-- CEQ @9                  	 verifica se é igual a 1
163	: 0111010111000;	-- JEQ .DIGITO_1_ML     	 se for
164	: 1000000001010;	-- CEQ @10                 	 verifica se é igual a 2
165	: 0111011000101;	-- JEQ .DIGITO_2_ML     	 se for
166	: 1000000001011;	-- CEQ @11                 	 verifica se é igual a 3
167	: 0111011010010;	-- JEQ .DIGITO_3_ML     	 se for
168	: 1000000001100;	-- CEQ @12                 	 verifica se é igual a 4
169	: 0111011011111;	-- JEQ .DIGITO_4_ML     	 se for
170	: 0110011101100;	-- JMP .DIGITO_5_ML 		 se não for nenhum dos acima
171	: 0001101000000;	-- LDA @320    	 carrega o valor das chaves
172	: 0101100100000;	-- STA @288    	 armazena no HEX 0
173	: 0001000111011;	-- LDA @59			 carrega o valor da dezena do limite
174	: 0101100100001;	-- STA @289    	 armazena no HEX 1
175	: 0001000111100;	-- LDA @60			 carrega o valor de centena do limite
176	: 0101100100010;	-- STA @290    	 armazena no HEX 2
177	: 0001000111101;	-- LDA @61     	 carrega o valor do milhar do limite
178	: 0101100100011;	-- STA @291    	 armazena no HEX 3
179	: 0001000111110;	-- LDA @62     	 carrega o valor da dezena de milhar do limite
180	: 0101100100100;	-- STA @292    	 armazena no HEX 4
181	: 0001000111111;	-- LDA @63     	 carrega o valor da centena de milhar do limite
182	: 0101100100101;	-- STA @293    	 armazena no HEX 5
183	: 1010000000000;	-- RET
184	: 0001000111010;	-- LDA @58     	 carrega o valor da unidade do limite
185	: 0101100100000;	-- STA @288    	 armazena no HEX 0
186	: 0001101000000;	-- LDA @320    	 carrega o valor das chaves
187	: 0101100100001;	-- STA @289    	 armazena no HEX 1
188	: 0001000111100;	-- LDA @60     	 carrega o valor da centena do limite
189	: 0101100100010;	-- STA @290    	 armazena no HEX 2
190	: 0001000111101;	-- LDA @61     	 carrega o valor do milhar do limite
191	: 0101100100011;	-- STA @291    	 armazena no HEX 3
192	: 0001000111110;	-- LDA @62     	 carrega o valor da dezena de milhar do limite
193	: 0101100100100;	-- STA @292    	 armazena no HEX 4
194	: 0001000111111;	-- LDA @63     	 carrega o valor da centena de milhar do limite
195	: 0101100100101;	-- STA @293    	 armazena no HEX 5
196	: 1010000000000;	-- RET
197	: 0001000111010;	-- LDA @58     	 carrega o valor da unidade do limite
198	: 0101100100000;	-- STA @288    	 armazena no HEX 0
199	: 0001000111011;	-- LDA @59			 carrega o valor da dezena do limite
200	: 0101100100001;	-- STA @289    	 armazena no HEX 1
201	: 0001101000000;	-- LDA @320    	 carrega o valor das chaves
202	: 0101100100010;	-- STA @290    	 armazena no HEX 2
203	: 0001000111101;	-- LDA @61     	 carrega o valor do milhar do limite
204	: 0101100100011;	-- STA @291    	 armazena no HEX 3
205	: 0001000111110;	-- LDA @62     	 carrega o valor da dezena de milhar do limite
206	: 0101100100100;	-- STA @292    	 armazena no HEX 4
207	: 0001000111111;	-- LDA @63     	 carrega o valor da centena de milhar do limite
208	: 0101100100101;	-- STA @293    	 armazena no HEX 5
209	: 1010000000000;	-- RET
210	: 0001000111010;	-- LDA @58     	 carrega o valor da unidade do limite
211	: 0101100100000;	-- STA @288    	 armazena no HEX 0
212	: 0001000111011;	-- LDA @59			 carrega o valor da dezena do limite
213	: 0101100100001;	-- STA @289    	 armazena no HEX 1
214	: 0001000111100;	-- LDA @60    		 carrega o valor da centena do limite
215	: 0101100100010;	-- STA @290    	 armazena no HEX 2
216	: 0001101000000;	-- LDA @320    	 carrega o valor das chaves
217	: 0101100100011;	-- STA @291    	 armazena no HEX 3
218	: 0001000111110;	-- LDA @62     	 carrega o valor da dezena de milhar do limite
219	: 0101100100100;	-- STA @292    	 armazena no HEX 4
220	: 0001000111111;	-- LDA @63     	 carrega o valor da centena de milhar do limite
221	: 0101100100101;	-- STA @293    	 armazena no HEX 5
222	: 1010000000000;	-- RET
223	: 0001000111010;	-- LDA @58     	 carrega o valor da unidade do limite
224	: 0101100100000;	-- STA @288    	 armazena no HEX 0
225	: 0001000111011;	-- LDA @59			 carrega o valor da dezena do limite
226	: 0101100100001;	-- STA @289    	 armazena no HEX 1
227	: 0001000111100;	-- LDA @60    		 carrega o valor da centena do limite
228	: 0101100100010;	-- STA @290    	 armazena no HEX 2
229	: 0001000111101;	-- LDA @61     	 carrega o valor do milhar do limite
230	: 0101100100011;	-- STA @291    	 armazena no HEX 3
231	: 0001101000000;	-- LDA @320    	 carrega o valor das chaves
232	: 0101100100100;	-- STA @292    	 armazena no HEX 4
233	: 0001000111111;	-- LDA @63     	 carrega o valor da centena de milhar do limite
234	: 0101100100101;	-- STA @293    	 armazena no HEX 5
235	: 1010000000000;	-- RET
236	: 0001000111010;	-- LDA @58     	 carrega o valor da unidade do limite
237	: 0101100100000;	-- STA @288    	 armazena no HEX 0
238	: 0001000111011;	-- LDA @59			 carrega o valor da dezena do limite
239	: 0101100100001;	-- STA @289    	 armazena no HEX 1
240	: 0001000111100;	-- LDA @60    		 carrega o valor da centena do limite
241	: 0101100100010;	-- STA @290    	 armazena no HEX 2
242	: 0001000111101;	-- LDA @61     	 carrega o valor do milhar do limite
243	: 0101100100011;	-- STA @291    	 armazena no HEX 3
244	: 0001000111110;	-- LDA @62     	 carrega o valor da dezena de milhar do limite
245	: 0101100100100;	-- STA @292    	 armazena no HEX 4
246	: 0001101000000;	-- LDA @320     	 carrega o valor das chaves
247	: 0101100100101;	-- STA @293    	 armazena no HEX 5
248	: 1010000000000;	-- RET
249	: 0100000000000;	-- LDI $0
250	: 0101100000000;	-- STA @256
251	: 0101100000001;	-- STA @257
252	: 0101100000010;	-- STA @258
253	: 1010000000000;	-- RET
254	: 0001000111001;	-- LDA @57                 	 carrega o intervalo atual
255	: 1000000001000;	-- CEQ @8                  	 verifica se é igual a 0
256	: 0111100001010;	-- JEQ .DIGITO_0_MI     		 se for
257	: 1000000001001;	-- CEQ @9                  	 verifica se é igual a 1
258	: 0111100010100;	-- JEQ .DIGITO_1_MI     		 se for
259	: 1000000001010;	-- CEQ @10                 	 verifica se é igual a 2
260	: 0111100011110;	-- JEQ .DIGITO_2_MI     		 se for
261	: 1000000001011;	-- CEQ @11                 	 verifica se é igual a 3
262	: 0111100101000;	-- JEQ .DIGITO_3_MI     		 se for
263	: 1000000001100;	-- CEQ @12                 	 verifica se é igual a 4
264	: 0111100110011;	-- JEQ .DIGITO_4_MI     		 se for
265	: 0110100111101;	-- JMP .DIGITO_5_MI 			 se não for nenhum dos acima
266	: 0100000000001;	-- LDI $1			 atualiza o intervalo
267	: 0101000111001;	-- STA @57
268	: 0100000000110;	-- LDI $6			 acende os LEDs da segunda posição e apaga o resto
269	: 0101100000000;	-- STA @256
270	: 0100000000000;	-- LDI $0
271	: 0101100000001;	-- STA @257
272	: 0101100000010;	-- STA @258
273	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
274	: 0101000111010;	-- STA @58
275	: 1010000000000;	-- RET
276	: 0100000000010;	-- LDI $2			 atualiza o intervalo
277	: 0101000111001;	-- STA @57
278	: 0100000011000;	-- LDI $24			 acende os LEDs da terceira posição e apaga o resto
279	: 0101100000000;	-- STA @256
280	: 0100000000000;	-- LDI $0
281	: 0101100000001;	-- STA @257
282	: 0101100000010;	-- STA @258
283	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
284	: 0101000111011;	-- STA @59
285	: 1010000000000;	-- RET
286	: 0100000000011;	-- LDI $3			 atualiza o intervalo
287	: 0101000111001;	-- STA @57
288	: 0100001100000;	-- LDI $96			 acende os LEDs da quarta posição e apaga o resto
289	: 0101100000000;	-- STA @256
290	: 0100000000000;	-- LDI $0
291	: 0101100000001;	-- STA @257
292	: 0101100000010;	-- STA @258
293	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
294	: 0101000111100;	-- STA @60
295	: 1010000000000;	-- RET
296	: 0100000000100;	-- LDI $4			 atualiza o intervalo
297	: 0101000111001;	-- STA @57
298	: 0100010000000;	-- LDI $128		 acende os LEDs da quinta posição e apaga o resto
299	: 0101100000000;	-- STA @256
300	: 0100000000001;	-- LDI $1
301	: 0101100000001;	-- STA @257
302	: 0100000000000;	-- LDI $0
303	: 0101100000010;	-- STA @258
304	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
305	: 0101000111101;	-- STA @61
306	: 1010000000000;	-- RET
307	: 0100000000101;	-- LDI $5			 atualiza o intervalo
308	: 0101000111001;	-- STA @57
309	: 0100000000000;	-- LDI $0			 acende os LEDs da sexta posição e apaga o resto
310	: 0101100000000;	-- STA @256
311	: 0100000000001;	-- LDI $1
312	: 0101100000001;	-- STA @257
313	: 0101100000010;	-- STA @258
314	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
315	: 0101000111110;	-- STA @62
316	: 1010000000000;	-- RET
317	: 0100000000000;	-- LDI $0			 atualiza o intervalo
318	: 0101000111001;	-- STA @57
319	: 0100000000011;	-- LDI $3			 acende os LEDs da primeira posição e apaga o resto
320	: 0101100000000;	-- STA @256
321	: 0100000000000;	-- LDI $0
322	: 0101100000001;	-- STA @257
323	: 0101100000010;	-- STA @258
324	: 0001101000000;	-- LDA @320		 salva o novo valor do dígito
325	: 0101000111111;	-- STA @63
326	: 1010000000000;	-- RET
327	: 0001000000101;	-- LDA @5			 carrega o valor da centena de milhar
328	: 1000000111111;	-- CEQ @63			 compara com o valor limite da centena de milhar
329	: 0111101001100;	-- JEQ .CMILHAR_ATINGIU
330	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
331	: 1010000000000;	-- RET
332	: 0001000000100;	-- LDA @4			 carrega o valor da dezena de milhar
333	: 1000000111110;	-- CEQ @62			 compara com o valor limite da dezena de milhar
334	: 0111101010001;	-- JEQ .DMILHAR_ATINGIU
335	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
336	: 1010000000000;	-- RET
337	: 0001000000011;	-- LDA @3			 carrega o valor do milhar
338	: 1000000111101;	-- CEQ @61			 compara com o valor limite do milhar
339	: 0111101010110;	-- JEQ .MILHAR_ATINGIU
340	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
341	: 1010000000000;	-- RET
342	: 0001000000010;	-- LDA @2			 carrega o valor da centena
343	: 1000000111100;	-- CEQ @60			 compara com o valor limite da centena
344	: 0111101011011;	-- JEQ .CENTENA_ATINGIU
345	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
346	: 1010000000000;	-- RET
347	: 0001000000001;	-- LDA @1			 carrega o valor da dezena
348	: 1000000111011;	-- CEQ @59			 compara com o valor limite da dezena
349	: 0111101100000;	-- JEQ .DEZENA_ATINGIU
350	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
351	: 1010000000000;	-- RET
352	: 0001000000000;	-- LDA @0			 carrega o valor da unidade
353	: 1000000111010;	-- CEQ @58			 compara com o valor limite da unidade
354	: 0111101100101;	-- JEQ .UNIDADE_ATINGIU
355	: 0100000000000;	-- LDI $0			 se não for igual, não atingiu
356	: 1010000000000;	-- RET
357	: 0100011111111;	-- LDI $255
358	: 0101100000000;	-- STA @256
359	: 0101100000001;	-- STA @257
360	: 0101100000010;	-- STA @258
361	: 0100000000001;	-- LDI $1
362	: 1010000000000;	-- RET
[363..511]	:	0000000000000;
END;